1. 什么是垃圾回收？
   当声明一个变量或者赋值时，js引擎都会分配一块内存。
    垃圾是指存储在内存中但是没有被引用的变量。js引擎会定时的自动清除没有被引用的变量，以释放内存。

2. 如何进行垃圾回收
    (1)标记清除：这个方法是大多数浏览器使用的方法，包括Chrome，IE，Firefox，Opera、
                js引擎会给内存中所以的变量都进行标记，然后从根开始进行访问，能访问到的就将该标记去掉。
                最后全部剩下标记的不能访问到的变量，在下一次垃圾回收时，将这些带有标记的变量进行清除。
    (2)引用计数：每有一个变量引用该值时，就将该值的引用次数+1， 当引用次数为0时，js引擎会将其清除。

    JS 中引用计数垃圾回收策略的问题
先简单讲一下 JS 中引用垃圾回收策略大体是什么样的一个原理，当一个变量被赋予一个引用类型的值时，这个引用类型的值的引用计数加 1。
就像是代码中的 obj1 这个变量被赋予了 obj1 这个对象的地址，obj1 这个变量就指向了这个 obj1(右上)这个对象，obj1(右上)的引用计数就会加1.
当变量 obj1的值不再是 obj1(右上)这个对象的地址时，obj1(右上)这个对象的引用计数就会减1.
当这个 obj1（右上）对象的引用计数变成 0 后，垃圾收集器就会将其回收，因为此时没有变量指向你，也就没办法使用你了。

看似很合理的垃圾回收策略为什么会有问题呢？
就是上面讲到的循环引用导致的，下面来分析一下。当 obj1 这个变量执行 obj1 这个对象时，obj1 这个对象的引用计数会加 1，此时引用计数值为 1，
接下来 obj2 的 b 属性又指向了 obj1 这个对象，所以此时 obj1 这个对象的引用计数为 2。
同理 obj2 这个对象的引用计数也为2.
当代码执行完后，会将变量 obj1 和 obj2 赋值为 null，但是此时 obj1 和 obj2 这两个对象的引用计数都为1，并不为 0，所以并不会进行垃圾回收，
但是这两个对象已经没有作用了，在函数外部也不可能使用到它们，所以这就造成了内存泄露。
在现在广泛采用的标记清除回收策略中就不会出现上面的问题，标记清除回收策略的大致流程是这样的，
最开始的时候将所有的变量加上标记，当执行 cycularReference 函数的时候会将函数内部的变量这些标记清除，
在函数执行完后再加上标记。这些被清除标记又被加上标记的变量就被视为将要删除的变量，原因是这些函数中的变量已经无法被访问到了。
像上述代码中的 obj1 和 obj2 这两个变量在刚开始时有标记，进入函数后被清除标记，
然后函数执行完后又被加上标记被视为将要清除的变量，因此不会出现引用计数中出现的问题，因为标记清除并不会关心引用的次数是多少。